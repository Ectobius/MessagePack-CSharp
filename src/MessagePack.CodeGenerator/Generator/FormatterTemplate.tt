<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

namespace <#= Namespace #>
{
    using System;
    using System.Collections.Generic;
    using MessagePack;
    using MessagePack.Formatters;

    internal class TypeRegistry
    {
        public static Dictionary<int, Type> Types { get; } = new Dictionary<int, Type>
        {
<# foreach(var objInfo in objectSerializationInfos) { #>
            { <#= objInfo.TypeId #>, typeof(<#= objInfo.FullName #>) },
<# } #>
        };
    }

<# foreach(var objInfo in objectSerializationInfos) { #>

    public sealed class <#= objInfo.Name #>Formatter : global::MessagePack.Formatters.IMessagePackFormatterWithPopulate<<#= objInfo.FullName #>>, IMessagePackUntypedFormatterWithPopulate, IMessagePackUntypedFormatter
    {
        private const int TypeId = <#= objInfo.TypeId #>;

        private global::MessagePack.ModelCreation.IModelFactory _modelFactory;

<# if( objInfo.IsStringKey) { #>

        readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        readonly byte[][] ____stringByteKeys;
        

        public <#= objInfo.Name #>Formatter(global::MessagePack.ModelCreation.IModelFactory modelFactory)
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
<# foreach(var x in objInfo.Members) { #>
                { "<#= x.StringKey #>", <#= x.IntKey #>},
<# } #>
            };

            this.____stringByteKeys = new byte[][]
            {
<# foreach(var x in objInfo.Members.Where(x => x.IsReadable)) { #>
                global::MessagePack.MessagePackBinary.GetEncodedStringBytes("<#= x.StringKey #>"),
<# } #>                
            };

            this._modelFactory = modelFactory;
        }

<#  } else { #>
        public <#= objInfo.Name #>Formatter(global::MessagePack.ModelCreation.IModelFactory modelFactory)
        {
            this._modelFactory = modelFactory;
        }
<#  } #>

        public int Serialize(ref byte[] bytes, int offset, <#= objInfo.FullName #> value, global::MessagePack.IFormatterResolver formatterResolver, SerializationContext context)
        {
<# if( objInfo.IsClass) { #>
            if (value == null)
            {
                return global::MessagePack.MessagePackBinary.WriteNil(ref bytes, offset);
            }            
<# } #>

            var startOffset = offset;

            if (context.CheckIfExternal(value))
            {
                var externalObjectId = context.PutToExternalObjects(value);
                offset += global::MessagePack.MessagePackBinary.WriteFixedArrayHeaderUnsafe(ref bytes, offset, 2);
                offset += global::MessagePack.MessagePackBinary.WriteInt32(ref bytes, offset, (int)global::MessagePack.ModelSerialization.ReservedTypes.ExternalReference);
                offset += global::MessagePack.MessagePackBinary.WriteInt32(ref bytes, offset, externalObjectId);
                return offset - startOffset;
            }

<# if (objInfo.DontSerialize) { #>

            offset += global::MessagePack.MessagePackBinary.WriteNil(ref bytes, offset);
            return offset - startOffset;

<# } else { #>
            if (value.GetType() != typeof(<#= objInfo.FullName #>))
            {
                if (formatterResolver is IUntypedFormatterResolver untypedFormatterResolver)
                {
                    var derivedTypeFormatter = untypedFormatterResolver.GetFormatter(value.GetType());
                    return derivedTypeFormatter.Serialize(ref bytes, offset, value, formatterResolver, context);
                }
            }

<# if(objInfo.HasIMessagePackSerializationCallbackReceiver && objInfo.NeedsCastOnBefore) { #>
            ((IMessagePackSerializationCallbackReceiver)value).OnBeforeSerialize();
<# } else if(objInfo.HasIMessagePackSerializationCallbackReceiver) { #>
            value.OnBeforeSerialize();
<# } #>

            if (context != null && context.SerializedObjects.ContainsKey(value))
            {
                offset += global::MessagePack.MessagePackBinary.WriteFixedArrayHeaderUnsafe(ref bytes, offset, 2);
                offset += global::MessagePack.MessagePackBinary.WriteInt32(ref bytes, offset, (int) global::MessagePack.ModelSerialization.ReservedTypes.Reference);
                offset += global::MessagePack.MessagePackBinary.WriteInt32(ref bytes, offset, context.SerializedObjects[value]);
                return offset - startOffset;
            }

            int objectId = context.PutToSerialized(value);

<# int numberOfFields = objInfo.MaxKey + 3; #>

<# if( objInfo.IsIntKey) { if( (numberOfFields) <= 15) { #>
            offset += global::MessagePack.MessagePackBinary.WriteFixedArrayHeaderUnsafe(ref bytes, offset, <#= numberOfFields #>);
<# } else { #>
            offset += global::MessagePack.MessagePackBinary.WriteArrayHeader(ref bytes, offset, <#= numberOfFields #>);
<# } } else if( objInfo.WriteCount <= 15) { #>
            offset += global::MessagePack.MessagePackBinary.WriteFixedMapHeaderUnsafe(ref bytes, offset, <#= objInfo.WriteCount #>);
<# } else { #>
            offset += global::MessagePack.MessagePackBinary.WriteMapHeader(ref bytes, offset, <#= objInfo.WriteCount #>);
<# } #>
<# if(objInfo.IsIntKey) { #>

            offset += global::MessagePack.MessagePackBinary.WriteInt32(ref bytes, offset, TypeId);
            offset += global::MessagePack.MessagePackBinary.WriteInt32(ref bytes, offset, objectId);

<# for(var i = 0; i <= objInfo.MaxKey; i++) { var member = objInfo.GetMember(i); #>
<# if( member == null) { #>
            offset += global::MessagePack.MessagePackBinary.WriteNil(ref bytes, offset);
<# } else { #>
            offset += <#= member.GetSerializeMethodString() #>;
<# } } } else { #>
<# var index = 0; foreach(var x in objInfo.Members) { #>
            offset += global::MessagePack.MessagePackBinary.WriteRaw(ref bytes, offset, this.____stringByteKeys[<#= index++ #>]);
            offset += <#= x.GetSerializeMethodString() #>;
<# } } #>
            return offset - startOffset;
<# } #>
        }

        public <#= objInfo.FullName #> Deserialize(byte[] bytes, int offset, global::MessagePack.IFormatterResolver formatterResolver, out int readSize, DeserializationContext context)
        {
            if (global::MessagePack.MessagePackBinary.IsNil(bytes, offset))
            {
<# if( objInfo.IsClass) { #>
                readSize = 1;
                return null;
<# } else { #>
                throw new InvalidOperationException("typecode is null, struct not supported");
<# } #>
            }

            var startOffset = offset;
<# if(objInfo.IsStringKey) { #>
            var length = global::MessagePack.MessagePackBinary.ReadMapHeader(bytes, offset, out readSize);
<# } else { #>
            var length = global::MessagePack.MessagePackBinary.ReadArrayHeader(bytes, offset, out readSize);
<# } #>
            offset += readSize;

            var writtedTypeId = MessagePackBinary.ReadInt32(bytes, offset, out readSize);
            offset += readSize;

            if (writtedTypeId == (int) global::MessagePack.ModelSerialization.ReservedTypes.ExternalReference)
            {
                var referencedObjectId = MessagePackBinary.ReadInt32(bytes, offset, out readSize);
                offset += readSize;
                readSize = offset - startOffset;

                if (context.ExternalObjectsByIds != null && context.ExternalObjectsByIds.ContainsKey(referencedObjectId))
                {
                    return (<#= objInfo.FullName #>) context.ExternalObjectsByIds[referencedObjectId];
                }

                return null;
            }

            if (writtedTypeId == (int) global::MessagePack.ModelSerialization.ReservedTypes.Reference)
            {
                var referencedObjectId = MessagePackBinary.ReadInt32(bytes, offset, out readSize);
                offset += readSize;
                readSize = offset - startOffset;
                
                if (context.DeserializedObjects.ContainsKey(referencedObjectId))
                {
                    return (<#= objInfo.FullName #>) context.DeserializedObjects[referencedObjectId];
                }
                return null;
            }

            if (writtedTypeId != TypeId)
            {
                var actualType = TypeRegistry.Types[writtedTypeId];
                if (!(formatterResolver is IUntypedFormatterResolver))
                {
                    throw new Exception("In order to deserialize derived types resolver should implement IUntypedFormatterResolver");
                }

                var untypedFormatterResolver = formatterResolver as IUntypedFormatterResolver;
                var formatter = untypedFormatterResolver.GetFormatter(actualType);

                offset = startOffset;
                return (<#= objInfo.FullName #>) formatter.Deserialize(bytes, offset, formatterResolver, out readSize, context);
            }

            var objectId = MessagePackBinary.ReadInt32(bytes, offset, out readSize);
            offset += readSize;

<# foreach(var x in objInfo.Members) { #>
            var __<#= x.Name #>__ = default(<#= x.TypeName #>);
<# } #>

            for (int i = 0; i < length - 2; i++)
            {
<# if(objInfo.IsStringKey) { #>
                var stringKey = global::MessagePack.MessagePackBinary.ReadStringSegment(bytes, offset, out readSize);
                offset += readSize;
                int key;
                if (!____keyMapping.TryGetValueSafe(stringKey, out key))
                {
                    readSize = global::MessagePack.MessagePackBinary.ReadNextBlock(bytes, offset);
                    goto NEXT_LOOP;
                }
<# } else { #>
                var key = i;
<# } #>

                switch (key)
                {
<# foreach(var x in objInfo.Members) { #>
                    case <#= x.IntKey #>:
                        __<#= x.Name #>__ = <#= x.GetDeserializeMethodString() #>;
                        break;
<# } #>
                    default:
                        readSize = global::MessagePack.MessagePackBinary.ReadNextBlock(bytes, offset);
                        break;
                }
<# if(objInfo.IsStringKey) { #>                
                NEXT_LOOP:
<# } #>
                offset += readSize;
            }

            readSize = offset - startOffset;

<# if (objInfo.DontSerialize) { #>
            
            return null;

<# } else { #>

            var ____result = _modelFactory.CreateModel<<#= objInfo.FullName #>>(); //new <#= objInfo.GetConstructorString()  #>;
<# foreach(var x in objInfo.Members.Where(x => x.IsWritable)) { #>
            ____result.<#= x.Name #> = __<#= x.Name #>__;
<# } #>
<#if(objInfo.HasIMessagePackSerializationCallbackReceiver && objInfo.NeedsCastOnAfter) { #>
            ((IMessagePackSerializationCallbackReceiver)____result).OnAfterDeserialize();
<# } else if(objInfo.HasIMessagePackSerializationCallbackReceiver) { #>
            ____result.OnAfterDeserialize();
<# } #>

            context.DeserializedObjects[objectId] = ____result;

            return ____result;

<# } #>
        }

        public int Serialize(ref byte[] bytes, int offset, object value, IFormatterResolver formatterResolver, SerializationContext context)
        {
            return Serialize(ref bytes, offset, (<#= objInfo.FullName #>) value, formatterResolver, context);
        }

        object IMessagePackFormatter<object>.Deserialize(byte[] bytes, int offset, IFormatterResolver formatterResolver, out int readSize, DeserializationContext context)
        {
            return Deserialize(bytes, offset, formatterResolver, out readSize, context);
        }

        public void Populate(ref <#= objInfo.FullName #> value, byte[] bytes, int offset, global::MessagePack.IFormatterResolver formatterResolver, out int readSize, DeserializationContext context)
        {
            if (global::MessagePack.MessagePackBinary.IsNil(bytes, offset))
            {
<# if( objInfo.IsClass) { #>
                readSize = 1;
                value = null;
                return;
<# } else { #>
                throw new InvalidOperationException("typecode is null, struct not supported");
<# } #>
            }

            var startOffset = offset;
<# if(objInfo.IsStringKey) { #>
            var length = global::MessagePack.MessagePackBinary.ReadMapHeader(bytes, offset, out readSize);
<# } else { #>
            var length = global::MessagePack.MessagePackBinary.ReadArrayHeader(bytes, offset, out readSize);
<# } #>
            offset += readSize;

            var writtedTypeId = MessagePackBinary.ReadInt32(bytes, offset, out readSize);
            offset += readSize;

            if (writtedTypeId == (int) global::MessagePack.ModelSerialization.ReservedTypes.ExternalReference)
            {
                var referencedObjectId = MessagePackBinary.ReadInt32(bytes, offset, out readSize);
                offset += readSize;
                readSize = offset - startOffset;

                if (context.ExternalObjectsByIds != null && context.ExternalObjectsByIds.ContainsKey(referencedObjectId))
                {
                    value = (<#= objInfo.FullName #>) context.ExternalObjectsByIds[referencedObjectId];
                    return;
                }

                value = null;
                return;
            }

            if (writtedTypeId == (int) global::MessagePack.ModelSerialization.ReservedTypes.Reference)
            {
                var referencedObjectId = MessagePackBinary.ReadInt32(bytes, offset, out readSize);
                offset += readSize;
                readSize = offset - startOffset;
                
                if (context.DeserializedObjects.ContainsKey(referencedObjectId))
                {
                    value = (<#= objInfo.FullName #>) context.DeserializedObjects[referencedObjectId];
                    return;
                }
                value = null;
                return;
            }

            var actualType = TypeRegistry.Types[writtedTypeId];

            if (writtedTypeId != TypeId)
            {
                var formatter = GetFormatterForActualType(actualType, formatterResolver);
                var formatterWithPopulate = (IMessagePackUntypedFormatterWithPopulate) formatter;

                var valueObject = (object)value;
                offset = startOffset;
                formatterWithPopulate.Populate(ref valueObject, bytes, offset, formatterResolver, out readSize, context);
                return;
            }

            if (actualType != value.GetType() && actualType.IsSubclassOf(value.GetType()))
            {
                var formatter = GetFormatterForActualType(actualType, formatterResolver);
                offset = startOffset;
                value = (<#= objInfo.FullName #>) formatter.Deserialize(bytes, offset, formatterResolver, out readSize, context);
                return;
            }

            var objectId = MessagePackBinary.ReadInt32(bytes, offset, out readSize);
            offset += readSize;

            for (int i = 0; i < length - 2; i++)
            {
<# if(objInfo.IsStringKey) { #>
                var stringKey = global::MessagePack.MessagePackBinary.ReadStringSegment(bytes, offset, out readSize);
                offset += readSize;
                int key;
                if (!____keyMapping.TryGetValueSafe(stringKey, out key))
                {
                    readSize = global::MessagePack.MessagePackBinary.ReadNextBlock(bytes, offset);
                    goto NEXT_LOOP;
                }
<# } else { #>
                var key = i;
<# } #>

                switch (key)
                {
<# foreach(var x in objInfo.Members) { #>
                    case <#= x.IntKey #>:
<# if (x.IsPrimitive()) { #>
                        value.<#= x.Name #> = <#= x.GetDeserializeMethodString() #>;
<# } else if (MessagePack.Resolvers.BuiltinResolver.TypeHasBuiltinFormatter(x.Type)) { #>
                        value.<#= x.Name #> = <#= x.GetDeserializeMethodString() #>;
<# } else { #>
                        var formatter<#= x.Name #> = formatterResolver.GetFormatterWithVerify<<#= x.TypeName #>>();
                        if (value.<#= x.Name #> != null && formatter<#= x.Name #> is IMessagePackFormatterWithPopulate<<#= x.TypeName #>> formatterWithPopulate<#= x.Name #>)
                        {
                            var __<#= x.Name #>__ = value.<#= x.Name #>;
                            formatterWithPopulate<#= x.Name #>.Populate(ref __<#= x.Name #>__, bytes, offset, formatterResolver, out readSize, context);
                            if (__<#= x.Name #>__ != value.<#= x.Name #>) {
                                value.<#= x.Name #> = __<#= x.Name #>__;
                            }
                        }
                        else
                        {
                            value.<#= x.Name #> = <#= x.GetDeserializeMethodString() #>;
                        }
<# } #>
                        break;
<# } #>
                    default:
                        readSize = global::MessagePack.MessagePackBinary.ReadNextBlock(bytes, offset);
                        break;
                }
<# if(objInfo.IsStringKey) { #>                
                NEXT_LOOP:
<# } #>
                offset += readSize;
            }

            context.DeserializedObjects[objectId] = value;

            readSize = offset - startOffset;
        }

        IMessagePackUntypedFormatter GetFormatterForActualType(Type actualType, IFormatterResolver formatterResolver)
        {
            if (!(formatterResolver is IUntypedFormatterResolver))
            {
                throw new Exception("In order to populate derived types resolver should implement IUntypedFormatterResolver");
            }

            var untypedFormatterResolver = (IUntypedFormatterResolver) formatterResolver;
            return untypedFormatterResolver.GetFormatter(actualType);
        }

        void IMessagePackFormatterWithPopulate<object>.Populate(ref object value, byte[] bytes, int offset, IFormatterResolver formatterResolver, out int readSize, DeserializationContext context)
        {
            var typedValue = (<#= objInfo.FullName #>) value;
            Populate(ref typedValue, bytes, offset, formatterResolver, out readSize, context);
        }
    }

<# } #>
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612